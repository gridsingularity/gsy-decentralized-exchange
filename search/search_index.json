{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Decentralized Energy Exchange Introduction The Decentralized Energy Exchange (DEX) aims to revolutionize the way energy is traded and managed by leveraging the power of distributed ledger technology, such as blockchain, and advanced distributed runtime functionalities. The target of the decentralized energy exchange is to design, develop, and implement a robust, secure, and efficient platform for energy trading in a decentralized environment. The Decentralized Energy Exchange can effectively facilitate peer-to-peer energy trading, optimize energy consumption and generation, and ultimately contribute to a more sustainable and resilient energy infrastructure. The documentation is intended for developers, architects, stakeholders, and decision-makers involved in the Decentralized Energy Exchange. It outlines the key components, interactions, and design principles that guide the development and implementation of the system, ensuring its scalability, modularity, and interoperability while maintaining high security and data privacy standards. For more info about Grid Singularity please visit the Grid Singularity website . Scope and Objectives This chapter describes the core components, interactions, and design principles of the Decentralized Energy Exchange. The scope and objectives include: Defining the key components and modules : The essential building blocks of the Decentralized Energy Exchange, including runtime, distributed ledger, communication protocols, and user interfaces. Describing the interactions between components : The interactions and data flows between various components and modules within the Decentralized Energy Exchange, ensuring efficient and secure communication. Establishing design principles and best practices : A set of design principles, patterns, and best practices that guide the development and implementation of the Decentralized Energy Exchange, promoting modularity, scalability, security, and maintainability. Addressing security and privacy concerns : Measures and techniques to safeguard sensitive information and ensure the integrity of the Decentralized Energy Exchange are highlighted and implemented, in order to ensure data privacy and security of the users. Facilitating interoperability and integration : The Decentralized Energy Exchange promotes the use of open standards, protocols, and APIs, enabling seamless integration with other systems, platforms, and technologies in the energy sector. Adapting to evolving requirements and technologies : The Decentralized Energy Exchange is designed to be flexible and adaptable, allowing for the incorporation of new technologies, innovations, and evolving market requirements in the energy trading landscape. By adhering to the scope and objectives outlined in this chapter, the Decentralized Energy Exchange can effectively support the energy trading ecosystem, offering a secure, efficient, and transparent platform for peer-to-peer energy transactions. Design Principles The Decentralized Energy Exchange is designed around a set of key principles that guide its development and ensure that it meets the requirements of a modern, efficient, and secure energy trading platform. These design principles are aligned with the use of the Substrate framework for the development of the distributed ledger combined with the definition of a set of complementary ancillary services. Modularity : The Decentralized Energy Exchange is built on a modular structure, enabling each component to be developed, tested, and maintained independently. This modularity simplifies the development process and allows for easy integration of new features, modules, or services in the future. Scalability : The Decentralized Energy Exchange is designed to scale horizontally, accommodating the growing number of participants, transactions, and data. The use of Substrate allows for a highly scalable and efficient distributed ledger, while the ancillary services can also scale independently to handle increased loads. Interoperability : The Decentralized Energy Exchange promotes the use of open standards, protocols, and APIs to facilitate seamless integration with other systems, platforms, and technologies in the energy sector. This approach enables the Decentralized Energy Exchange to easily interact with other energy management systems, IoT devices, and existing infrastructure. Security : Ensuring the security and integrity of the Decentralized Energy Exchange is a top priority. The Substrate framework provides robust security features, including strong cryptographic algorithms and a proven consensus mechanism. In addition, the ancillary services and communication protocols must be designed with security best practices in mind, including encryption, access control, and secure data storage. Decentralization : The Decentralized Energy Exchange leverages the power of blockchain technology to enable a fully decentralized system. This approach eliminates the need for a central authority, ensuring a transparent, secure, and efficient energy trading platform that is less susceptible to manipulation or control by any single entity. Flexibility : The Decentralized Energy Exchange is designed to be adaptable and capable of incorporating new technologies, innovations, and evolving market requirements. This flexibility is achieved through the use of modular components, extensible APIs, and a development process that encourages innovation and experimentation. Usability : The user experience is an essential aspect of the Decentralized Energy Exchange. The Decentralized Energy Exchange should be easy to use and accessible to a wide range of users, including energy producers, consumers, grid operators, and regulators. The user interfaces and APIs should be designed with simplicity, efficiency, and intuitiveness in mind. By following these design principles, the Decentralized Energy Exchange can effectively support the growing needs of the energy trading ecosystem and provide a secure, efficient, and transparent platform for peer-to-peer energy transactions. System Components The Decentralized Energy Exchange is composed of several components that work together to provide a secure, scalable, and efficient platform for energy trading. The core of the Decentralized Energy Exchange is built using the Substrate framework, which provides the distributed ledger and custom runtime for implementing the state transition functions required for the energy exchange. Additionally, the system includes a set of ancillary services that enable further scalability and security. Substrate-based Node The Substrate-based node is the backbone of the Decentralized Energy Exchange, consisting of two main parts: Client with outer node services : This component handles network activities such as peer discovery, managing transaction requests, reaching consensus with peers, and responding to RPC calls. Custom Runtime : This component contains all the business logic for executing the state transition functions of the blockchain. The custom runtime is designed to improve the Decentralized Energy Exchange security, scalability, and reduce attack surfaces, as opposed to using smart contracts on a generalized virtual machine. Please to fine more info about the node in the Node Section . User Guide Installation Rust Setup Build & Run Test Connect UI Docker Node Runtime Pallets Primitives","title":"Home"},{"location":"#decentralized-energy-exchange","text":"","title":"Decentralized Energy Exchange"},{"location":"#introduction","text":"The Decentralized Energy Exchange (DEX) aims to revolutionize the way energy is traded and managed by leveraging the power of distributed ledger technology, such as blockchain, and advanced distributed runtime functionalities. The target of the decentralized energy exchange is to design, develop, and implement a robust, secure, and efficient platform for energy trading in a decentralized environment. The Decentralized Energy Exchange can effectively facilitate peer-to-peer energy trading, optimize energy consumption and generation, and ultimately contribute to a more sustainable and resilient energy infrastructure. The documentation is intended for developers, architects, stakeholders, and decision-makers involved in the Decentralized Energy Exchange. It outlines the key components, interactions, and design principles that guide the development and implementation of the system, ensuring its scalability, modularity, and interoperability while maintaining high security and data privacy standards. For more info about Grid Singularity please visit the Grid Singularity website .","title":"Introduction"},{"location":"#scope-and-objectives","text":"This chapter describes the core components, interactions, and design principles of the Decentralized Energy Exchange. The scope and objectives include: Defining the key components and modules : The essential building blocks of the Decentralized Energy Exchange, including runtime, distributed ledger, communication protocols, and user interfaces. Describing the interactions between components : The interactions and data flows between various components and modules within the Decentralized Energy Exchange, ensuring efficient and secure communication. Establishing design principles and best practices : A set of design principles, patterns, and best practices that guide the development and implementation of the Decentralized Energy Exchange, promoting modularity, scalability, security, and maintainability. Addressing security and privacy concerns : Measures and techniques to safeguard sensitive information and ensure the integrity of the Decentralized Energy Exchange are highlighted and implemented, in order to ensure data privacy and security of the users. Facilitating interoperability and integration : The Decentralized Energy Exchange promotes the use of open standards, protocols, and APIs, enabling seamless integration with other systems, platforms, and technologies in the energy sector. Adapting to evolving requirements and technologies : The Decentralized Energy Exchange is designed to be flexible and adaptable, allowing for the incorporation of new technologies, innovations, and evolving market requirements in the energy trading landscape. By adhering to the scope and objectives outlined in this chapter, the Decentralized Energy Exchange can effectively support the energy trading ecosystem, offering a secure, efficient, and transparent platform for peer-to-peer energy transactions.","title":"Scope and Objectives"},{"location":"#design-principles","text":"The Decentralized Energy Exchange is designed around a set of key principles that guide its development and ensure that it meets the requirements of a modern, efficient, and secure energy trading platform. These design principles are aligned with the use of the Substrate framework for the development of the distributed ledger combined with the definition of a set of complementary ancillary services. Modularity : The Decentralized Energy Exchange is built on a modular structure, enabling each component to be developed, tested, and maintained independently. This modularity simplifies the development process and allows for easy integration of new features, modules, or services in the future. Scalability : The Decentralized Energy Exchange is designed to scale horizontally, accommodating the growing number of participants, transactions, and data. The use of Substrate allows for a highly scalable and efficient distributed ledger, while the ancillary services can also scale independently to handle increased loads. Interoperability : The Decentralized Energy Exchange promotes the use of open standards, protocols, and APIs to facilitate seamless integration with other systems, platforms, and technologies in the energy sector. This approach enables the Decentralized Energy Exchange to easily interact with other energy management systems, IoT devices, and existing infrastructure. Security : Ensuring the security and integrity of the Decentralized Energy Exchange is a top priority. The Substrate framework provides robust security features, including strong cryptographic algorithms and a proven consensus mechanism. In addition, the ancillary services and communication protocols must be designed with security best practices in mind, including encryption, access control, and secure data storage. Decentralization : The Decentralized Energy Exchange leverages the power of blockchain technology to enable a fully decentralized system. This approach eliminates the need for a central authority, ensuring a transparent, secure, and efficient energy trading platform that is less susceptible to manipulation or control by any single entity. Flexibility : The Decentralized Energy Exchange is designed to be adaptable and capable of incorporating new technologies, innovations, and evolving market requirements. This flexibility is achieved through the use of modular components, extensible APIs, and a development process that encourages innovation and experimentation. Usability : The user experience is an essential aspect of the Decentralized Energy Exchange. The Decentralized Energy Exchange should be easy to use and accessible to a wide range of users, including energy producers, consumers, grid operators, and regulators. The user interfaces and APIs should be designed with simplicity, efficiency, and intuitiveness in mind. By following these design principles, the Decentralized Energy Exchange can effectively support the growing needs of the energy trading ecosystem and provide a secure, efficient, and transparent platform for peer-to-peer energy transactions.","title":"Design Principles"},{"location":"#system-components","text":"The Decentralized Energy Exchange is composed of several components that work together to provide a secure, scalable, and efficient platform for energy trading. The core of the Decentralized Energy Exchange is built using the Substrate framework, which provides the distributed ledger and custom runtime for implementing the state transition functions required for the energy exchange. Additionally, the system includes a set of ancillary services that enable further scalability and security.","title":"System Components"},{"location":"#substrate-based-node","text":"The Substrate-based node is the backbone of the Decentralized Energy Exchange, consisting of two main parts: Client with outer node services : This component handles network activities such as peer discovery, managing transaction requests, reaching consensus with peers, and responding to RPC calls. Custom Runtime : This component contains all the business logic for executing the state transition functions of the blockchain. The custom runtime is designed to improve the Decentralized Energy Exchange security, scalability, and reduce attack surfaces, as opposed to using smart contracts on a generalized virtual machine. Please to fine more info about the node in the Node Section .","title":"Substrate-based Node"},{"location":"#user-guide","text":"Installation Rust Setup Build & Run Test Connect UI Docker Node Runtime Pallets Primitives","title":"User Guide"},{"location":"node/node/","text":"Node A blockchain node is an application that allows users to participate in a blockchain network. Substrate-based blockchain nodes expose a number of capabilities: Networking: Substrate nodes use the libp2p networking stack to allow the nodes in the network to communicate with one another. Consensus: Blockchains must have a way to come to consensus on the state of the network. Substrate makes it possible to supply custom consensus engines and also ships with several consensus mechanisms that have been built on top of Web3 Foundation research . RPC Server: A remote procedure call (RPC) server is used to interact with Substrate nodes. There are several files in the node directory - take special note of the following: chain_spec.rs : A chain specification is a source code file that defines a Substrate chain's initial (genesis) state. Chain specifications are useful for development and testing, and critical when architecting the launch of a production chain. Take note of the development_config and testnet_genesis functions, which are used to define the genesis state for the local development chain configuration. These functions identify some well-known accounts and use them to configure the blockchain's initial state. service.rs : This file defines the node implementation. Take note of the libraries that this file imports and the names of the functions it invokes. In particular, there are references to consensus-related topics, such as the longest chain rule , the Aura block authoring mechanism and the GRANDPA finality gadget. After the node has been built , refer to the embedded documentation to learn more about the capabilities and configuration parameters that it exposes: ./target/release/gsy-node --help","title":"Node"},{"location":"node/node/#node","text":"A blockchain node is an application that allows users to participate in a blockchain network. Substrate-based blockchain nodes expose a number of capabilities: Networking: Substrate nodes use the libp2p networking stack to allow the nodes in the network to communicate with one another. Consensus: Blockchains must have a way to come to consensus on the state of the network. Substrate makes it possible to supply custom consensus engines and also ships with several consensus mechanisms that have been built on top of Web3 Foundation research . RPC Server: A remote procedure call (RPC) server is used to interact with Substrate nodes. There are several files in the node directory - take special note of the following: chain_spec.rs : A chain specification is a source code file that defines a Substrate chain's initial (genesis) state. Chain specifications are useful for development and testing, and critical when architecting the launch of a production chain. Take note of the development_config and testnet_genesis functions, which are used to define the genesis state for the local development chain configuration. These functions identify some well-known accounts and use them to configure the blockchain's initial state. service.rs : This file defines the node implementation. Take note of the libraries that this file imports and the names of the functions it invokes. In particular, there are references to consensus-related topics, such as the longest chain rule , the Aura block authoring mechanism and the GRANDPA finality gadget. After the node has been built , refer to the embedded documentation to learn more about the capabilities and configuration parameters that it exposes: ./target/release/gsy-node --help","title":"Node"},{"location":"node/pallets/","text":"Pallets The runtime in this project is constructed using many FRAME pallets that ship with the core Substrate repository and orderbook-registry , orderbook-worker and trades-settlement pallets that are defined in the ./modules directory. A FRAME pallet is compromised of a number of blockchain primitives: Storage: FRAME defines a rich set of powerful storage abstractions that makes it easy to use Substrate's efficient key-value database to manage the evolving state of a blockchain. Dispatchables: FRAME pallets define special types of functions that can be invoked (dispatched) from outside of the runtime in order to update its state. Events: Substrate uses events and errors to notify users of important changes in the runtime. Errors: When a dispatchable fails, it returns an error. Config: The Config configuration interface is used to define the types and parameters upon which a FRAME pallet depends. Orderbook Registry Pallet The Orderbook Registry pallet provides a decentralized orderbook management system that allows users to register accounts, insert and delete orders, and manage proxies for delegating order management. Pallet Overview The pallet provides several key components: User and Matching Engine Operator registration. Proxy account management for users. Order management, including insertion and deletion. Storage Items RegisteredUser : Maps an AccountId to a Hash for registered users. RegisteredMatchingEngine : Maps an AccountId to a Hash for registered matching engine operators. ProxyAccounts : Maps an AccountId to a BoundedVec of ProxyDefinition for the registered proxy accounts. OrdersRegistry : Maps an OrderReference to an OrderStatus. Events MatchingEngineOperatorRegistered : Emitted when a new matching engine operator is registered. NewOrderInserted : Emitted when a new order is inserted. NewOrderInsertedByProxy : Emitted when a new order is inserted by a proxy account. AllOrdersInserted : Emitted when all orders in a batch are inserted. OrderDeleted : Emitted when an order is deleted. OrderDeletedByProxy : Emitted when an order is deleted by a proxy account. ProxyAccountRegistered : Emitted when a new proxy account is registered. ProxyAccountUnregistered : Emitted when a proxy account is unregistered. UserRegistered : Emitted when a new user is registered. Errors AlreadyRegistered : Returned when an account is already registered. AlreadyRegisteredProxyAccount : Returned when a proxy account is already registered. NoSelfProxy : Returned when an account tries to register itself as a proxy account. NotARegisteredMatchingEngineOperator : Returned when an account is not a registered matching engine operator. NotARegisteredProxyAccount : Returned when an account is not a registered proxy account. NotARegisteredUserAccount : Returned when an account is not a registered user account. NotARegisteredUserOrProxyAccount : Returned when an account is not a registered user or proxy account. NotRegisteredProxyAccounts : Returned when there are no registered proxy accounts. OpenOrderNotFound : Returned when an open order is not found. OrderAlreadyDeleted : Returned when an order is already deleted. OrderAlreadyExecuted : Returned when an order is already executed. OrderAlreadyInserted : Returned when an order is already inserted. ProxyAccountsLimitReached : Returned when the proxy accounts limit has been reached. Dispatchable Functions insert_orders : Insert an order with a given order hash for a registered user account. insert_orders_by_proxy : Insert an order with a given order hash for a registered user account by a registered proxy account. delete_order : Delete an order with a given order hash for a registered user account. delete_order_by_proxy : Delete an order with a given order hash for a registered user account by a registered proxy account. register_proxy_account : Register a new proxy account for a registered user account. register_matching_engine_operator : Register a new matching engine operator account. register_user : Register a new user account. unregister_proxy_account : Unregister a proxy account for a registered user account. Helper Functions add_matching_engine_operator : Add a matching engine operator account. add_proxy_account : Add a proxy account for a registered user account. add_user : Add a user account. is_order_registered : Check if an order is registered. is_registered_matching_engine_operator : Check if an account is a registered matching engine operator.","title":"Pallets"},{"location":"node/pallets/#pallets","text":"The runtime in this project is constructed using many FRAME pallets that ship with the core Substrate repository and orderbook-registry , orderbook-worker and trades-settlement pallets that are defined in the ./modules directory. A FRAME pallet is compromised of a number of blockchain primitives: Storage: FRAME defines a rich set of powerful storage abstractions that makes it easy to use Substrate's efficient key-value database to manage the evolving state of a blockchain. Dispatchables: FRAME pallets define special types of functions that can be invoked (dispatched) from outside of the runtime in order to update its state. Events: Substrate uses events and errors to notify users of important changes in the runtime. Errors: When a dispatchable fails, it returns an error. Config: The Config configuration interface is used to define the types and parameters upon which a FRAME pallet depends.","title":"Pallets"},{"location":"node/pallets/#orderbook-registry-pallet","text":"The Orderbook Registry pallet provides a decentralized orderbook management system that allows users to register accounts, insert and delete orders, and manage proxies for delegating order management.","title":"Orderbook Registry Pallet"},{"location":"node/pallets/#pallet-overview","text":"The pallet provides several key components: User and Matching Engine Operator registration. Proxy account management for users. Order management, including insertion and deletion.","title":"Pallet Overview"},{"location":"node/pallets/#storage-items","text":"RegisteredUser : Maps an AccountId to a Hash for registered users. RegisteredMatchingEngine : Maps an AccountId to a Hash for registered matching engine operators. ProxyAccounts : Maps an AccountId to a BoundedVec of ProxyDefinition for the registered proxy accounts. OrdersRegistry : Maps an OrderReference to an OrderStatus.","title":"Storage Items"},{"location":"node/pallets/#events","text":"MatchingEngineOperatorRegistered : Emitted when a new matching engine operator is registered. NewOrderInserted : Emitted when a new order is inserted. NewOrderInsertedByProxy : Emitted when a new order is inserted by a proxy account. AllOrdersInserted : Emitted when all orders in a batch are inserted. OrderDeleted : Emitted when an order is deleted. OrderDeletedByProxy : Emitted when an order is deleted by a proxy account. ProxyAccountRegistered : Emitted when a new proxy account is registered. ProxyAccountUnregistered : Emitted when a proxy account is unregistered. UserRegistered : Emitted when a new user is registered.","title":"Events"},{"location":"node/pallets/#errors","text":"AlreadyRegistered : Returned when an account is already registered. AlreadyRegisteredProxyAccount : Returned when a proxy account is already registered. NoSelfProxy : Returned when an account tries to register itself as a proxy account. NotARegisteredMatchingEngineOperator : Returned when an account is not a registered matching engine operator. NotARegisteredProxyAccount : Returned when an account is not a registered proxy account. NotARegisteredUserAccount : Returned when an account is not a registered user account. NotARegisteredUserOrProxyAccount : Returned when an account is not a registered user or proxy account. NotRegisteredProxyAccounts : Returned when there are no registered proxy accounts. OpenOrderNotFound : Returned when an open order is not found. OrderAlreadyDeleted : Returned when an order is already deleted. OrderAlreadyExecuted : Returned when an order is already executed. OrderAlreadyInserted : Returned when an order is already inserted. ProxyAccountsLimitReached : Returned when the proxy accounts limit has been reached.","title":"Errors"},{"location":"node/pallets/#dispatchable-functions","text":"insert_orders : Insert an order with a given order hash for a registered user account. insert_orders_by_proxy : Insert an order with a given order hash for a registered user account by a registered proxy account. delete_order : Delete an order with a given order hash for a registered user account. delete_order_by_proxy : Delete an order with a given order hash for a registered user account by a registered proxy account. register_proxy_account : Register a new proxy account for a registered user account. register_matching_engine_operator : Register a new matching engine operator account. register_user : Register a new user account. unregister_proxy_account : Unregister a proxy account for a registered user account.","title":"Dispatchable Functions"},{"location":"node/pallets/#helper-functions","text":"add_matching_engine_operator : Add a matching engine operator account. add_proxy_account : Add a proxy account for a registered user account. add_user : Add a user account. is_order_registered : Check if an order is registered. is_registered_matching_engine_operator : Check if an account is a registered matching engine operator.","title":"Helper Functions"},{"location":"node/primitives/","text":"GSy DEX Primitives The above Rust code defines the core types used in the GSy-Decentralized Energy Exchange. It includes various primitive data structures such as types for block numbers, moments, signatures, public keys, account IDs, account indices, chain IDs, hashes, nonces, balances, headers, blocks, and extrinsics. Additionally, it exports the OrderReference and OrderStatus types from the orders module. Here is an overview of the data structures defined in the code: BlockNumber : a type alias for a 64-bit unsigned integer used to represent block numbers in the GSy-Decentralized Energy Exchange. Moment : a type alias for a 64-bit unsigned integer used to represent an instant or duration in time. Signature : a type alias for the MultiSignature type from the sp_runtime module. This type is used to represent a signature for a transaction on the GSy chain. It allows one of several underlying cryptographic algorithms to be used, so it isn't a fixed size when encoded. AccountPublic : a type alias for the Signer associated type of the Verify trait implemented for Signature . This type represents the public key used for the GSy chain and is actually a MultiSigner . Like the signature, this type also isn't a fixed size when encoded, as different cryptographic algorithms have different size public keys. AccountId : a type alias for the AccountId32 type associated with the IdentifyAccount trait implemented for AccountPublic . This type is an opaque account ID type for the GSy chain and is always 32 bytes. AccountIndex : a type alias for a 32-bit unsigned integer used to represent the type for looking up accounts. ChainId : a type alias for a 32-bit unsigned integer used to represent the identifier for a chain. Hash : a type alias for the H256 type from the sp_core module. This type is used to represent a hash of some data used by the GSy chain. Nonce : a type alias for a 32-bit unsigned integer used to represent the index of a transaction in the relay chain. Balance : a type alias for a 128-bit unsigned integer used to represent the balance of an account on the GSy chain. Header : a type alias for the generic::Header<BlockNumber, BlakeTwo256> type from the sp_runtime module. This type represents the header of a block in the GSy-Decentralized Energy Exchange. Block : a type alias for the generic::Block<Header, UncheckedExtrinsic> type from the sp_runtime module. This type represents a block in the GSy-Decentralized Energy Exchange. BlockId : a type alias for the generic::BlockId<Block> type from the sp_runtime module. This type represents the ID of a block in the GSy-Decentralized Energy Exchange. UncheckedExtrinsic : an opaque, encoded, unchecked extrinsic that is used to represent a transaction on the GSy chain. OrderReference : a type defined in the orders module that represents a reference to an order in the GSy-Decentralized Energy Exchange. OrderStatus : a type defined in the orders module that represents the status of an order in the GSy-Decentralized Energy Exchange. mod orders : a module that exports the OrderReference and OrderStatus types. The orders Module The orders module defines two types: OrderStatus : An enum that represents the status of an order in the GSy-Decentralized Energy Exchange. It has three variants: Open : The default status. Executed : The order has been executed. Deleted : The order has been cancelled. OrderReference : A struct that represents a reference to an order in the GSy-Decentralized Energy Exchange. It has two fields: user_id : The account ID of the user who created the order. hash : The hash of the order struct which represent a unique reference. Primitives Diagram classDiagram class BlockNumber { +u64 } class Moment { +u64 } class Signature { +MultiSignature } class AccountPublic { +MultiSigner } class AccountId { +AccountId32 } class AccountIndex { +u32 } classDiagram class ChainId { +u32 } class Hash { +H256 } class Nonce { +u32 } class Balance { +u128 } class Header { +generic::Header } class Block { +generic::Block } classDiagram class BlockId { +generic::BlockId } class UncheckedExtrinsic { +EncodedExtrinsic } class OrderReference { +user_id: AccountId +hash: Hash } class OrderStatus { +Open +Executed +Deleted }","title":"Primitives"},{"location":"node/primitives/#gsy-dex-primitives","text":"The above Rust code defines the core types used in the GSy-Decentralized Energy Exchange. It includes various primitive data structures such as types for block numbers, moments, signatures, public keys, account IDs, account indices, chain IDs, hashes, nonces, balances, headers, blocks, and extrinsics. Additionally, it exports the OrderReference and OrderStatus types from the orders module. Here is an overview of the data structures defined in the code: BlockNumber : a type alias for a 64-bit unsigned integer used to represent block numbers in the GSy-Decentralized Energy Exchange. Moment : a type alias for a 64-bit unsigned integer used to represent an instant or duration in time. Signature : a type alias for the MultiSignature type from the sp_runtime module. This type is used to represent a signature for a transaction on the GSy chain. It allows one of several underlying cryptographic algorithms to be used, so it isn't a fixed size when encoded. AccountPublic : a type alias for the Signer associated type of the Verify trait implemented for Signature . This type represents the public key used for the GSy chain and is actually a MultiSigner . Like the signature, this type also isn't a fixed size when encoded, as different cryptographic algorithms have different size public keys. AccountId : a type alias for the AccountId32 type associated with the IdentifyAccount trait implemented for AccountPublic . This type is an opaque account ID type for the GSy chain and is always 32 bytes. AccountIndex : a type alias for a 32-bit unsigned integer used to represent the type for looking up accounts. ChainId : a type alias for a 32-bit unsigned integer used to represent the identifier for a chain. Hash : a type alias for the H256 type from the sp_core module. This type is used to represent a hash of some data used by the GSy chain. Nonce : a type alias for a 32-bit unsigned integer used to represent the index of a transaction in the relay chain. Balance : a type alias for a 128-bit unsigned integer used to represent the balance of an account on the GSy chain. Header : a type alias for the generic::Header<BlockNumber, BlakeTwo256> type from the sp_runtime module. This type represents the header of a block in the GSy-Decentralized Energy Exchange. Block : a type alias for the generic::Block<Header, UncheckedExtrinsic> type from the sp_runtime module. This type represents a block in the GSy-Decentralized Energy Exchange. BlockId : a type alias for the generic::BlockId<Block> type from the sp_runtime module. This type represents the ID of a block in the GSy-Decentralized Energy Exchange. UncheckedExtrinsic : an opaque, encoded, unchecked extrinsic that is used to represent a transaction on the GSy chain. OrderReference : a type defined in the orders module that represents a reference to an order in the GSy-Decentralized Energy Exchange. OrderStatus : a type defined in the orders module that represents the status of an order in the GSy-Decentralized Energy Exchange. mod orders : a module that exports the OrderReference and OrderStatus types.","title":"GSy DEX Primitives"},{"location":"node/primitives/#the-orders-module","text":"The orders module defines two types: OrderStatus : An enum that represents the status of an order in the GSy-Decentralized Energy Exchange. It has three variants: Open : The default status. Executed : The order has been executed. Deleted : The order has been cancelled. OrderReference : A struct that represents a reference to an order in the GSy-Decentralized Energy Exchange. It has two fields: user_id : The account ID of the user who created the order. hash : The hash of the order struct which represent a unique reference.","title":"The orders Module"},{"location":"node/primitives/#primitives-diagram","text":"classDiagram class BlockNumber { +u64 } class Moment { +u64 } class Signature { +MultiSignature } class AccountPublic { +MultiSigner } class AccountId { +AccountId32 } class AccountIndex { +u32 } classDiagram class ChainId { +u32 } class Hash { +H256 } class Nonce { +u32 } class Balance { +u128 } class Header { +generic::Header } class Block { +generic::Block } classDiagram class BlockId { +generic::BlockId } class UncheckedExtrinsic { +EncodedExtrinsic } class OrderReference { +user_id: AccountId +hash: Hash } class OrderStatus { +Open +Executed +Deleted }","title":"Primitives Diagram"},{"location":"node/runtime/","text":"Runtime In Substrate, the terms \" runtime \" and \" state transition function \" are analogous - they refer to the core logic of the blockchain that is responsible for validating blocks and executing the state changes they define. The Substrate project in this repository uses the FRAME framework to construct a blockchain runtime. FRAME allows runtime developers to declare domain-specific logic in modules called \"pallets\". At the heart of FRAME is a helpful macro language that makes it easy to create pallets and flexibly compose them to create blockchains that can address a variety of needs . Review the FRAME runtime implementation included in the node source code ./runtime/src/lib.rs and note the following: This file configures several pallets to include in the runtime. Each pallet configuration is defined by a code block that begins with impl $PALLET_NAME::Config for Runtime . The pallets are composed into a single runtime by way of the construct_runtime! macro, which is part of the core FRAME Support library.","title":"Runtime"},{"location":"node/runtime/#runtime","text":"In Substrate, the terms \" runtime \" and \" state transition function \" are analogous - they refer to the core logic of the blockchain that is responsible for validating blocks and executing the state changes they define. The Substrate project in this repository uses the FRAME framework to construct a blockchain runtime. FRAME allows runtime developers to declare domain-specific logic in modules called \"pallets\". At the heart of FRAME is a helpful macro language that makes it easy to create pallets and flexibly compose them to create blockchains that can address a variety of needs . Review the FRAME runtime implementation included in the node source code ./runtime/src/lib.rs and note the following: This file configures several pallets to include in the runtime. Each pallet configuration is defined by a code block that begins with impl $PALLET_NAME::Config for Runtime . The pallets are composed into a single runtime by way of the construct_runtime! macro, which is part of the core FRAME Support library.","title":"Runtime"},{"location":"setup/build/","text":"Build The cargo run command will perform an initial build. Use the following command to build the node without launching it: cd gsy-node cargo build --release Embedded Docs Once the project has been built, the following command can be used to explore all parameters and subcommands: ./target/release/gsy-node -h Run Use Rust's native cargo command to build and launch the gsy-node: cd gsy-node cargo run --release -- --dev --tmp or if you have already built using cargo build you can launch the gsy-node using the following command: ./target/release/gsy-node --dev --tmp You should always use the --release flag to build optimized artifacts. The command-line options specify how you want the running node to operate. In this case, the --dev option specifies that the node runs in development mode using the predefined development chain specification. By default, this option also deletes all active data\u2014such as keys, the blockchain database, and networking information when you stop the node by pressing Control-c. Using the --dev option ensures that you have a clean working state any time you stop and restart the node. Verify your node is up and running successfully by reviewing the output displayed in the terminal. The terminal should display output similar to this: 2022-08-16 13:43:58 Substrate Node 2022-08-16 13:43:58 \u270c\ufe0f version 4.0.0-dev-de262935ede 2022-08-16 13:43:58 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2022 2022-08-16 13:43:58 \ud83d\udccb Chain specification: Development 2022-08-16 13:43:58 \ud83c\udff7 Node name: limping-oatmeal-7460 2022-08-16 13:43:58 \ud83d\udc64 Role: AUTHORITY 2022-08-16 13:43:58 \ud83d\udcbe Database: RocksDb at /var/folders/2_/g86ns85j5l7fdnl621ptzn500000gn/T/substrate95LPvM/chains/dev/db/full 2022-08-16 13:43:58 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2022-08-16 13:43:58 \ud83d\udd28 Initializing Genesis block/state (state: 0xf6f5\u2026423f, header-hash: 0xc665\u2026cf6a) 2022-08-16 13:43:58 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2022-08-16 13:43:59 Using default protocol ID \"sup\" because none is configured in the chain specs 2022-08-16 13:43:59 \ud83c\udff7 Local node identity is: 12D3KooWCu9uPCYZVsayaCKLdZLF8CmqiHkX2wHsAwSYVc2CxmiE ... ... ... ... 2022-08-16 13:54:26 \ud83d\udca4 Idle (0 peers), best: #3 (0xcdac\u202626e5), finalized #1 (0x107c\u20269bae), \u2b07 0 \u2b06 0 If the number after finalized is increasing, your blockchain is producing new blocks and reaching consensus about the state they describe. Single-Node Development Chain This command will start the single-node development chain with persistent state: ./target/release/gsy-node --dev Purge the development chain's state: ./target/release/gsy-node purge-chain --dev Start the development chain with detailed logging: RUST_BACKTRACE=1 ./target/release/gsy-node -ldebug --dev","title":"Build"},{"location":"setup/build/#build","text":"The cargo run command will perform an initial build. Use the following command to build the node without launching it: cd gsy-node cargo build --release","title":"Build"},{"location":"setup/build/#embedded-docs","text":"Once the project has been built, the following command can be used to explore all parameters and subcommands: ./target/release/gsy-node -h","title":"Embedded Docs"},{"location":"setup/build/#run","text":"Use Rust's native cargo command to build and launch the gsy-node: cd gsy-node cargo run --release -- --dev --tmp or if you have already built using cargo build you can launch the gsy-node using the following command: ./target/release/gsy-node --dev --tmp You should always use the --release flag to build optimized artifacts. The command-line options specify how you want the running node to operate. In this case, the --dev option specifies that the node runs in development mode using the predefined development chain specification. By default, this option also deletes all active data\u2014such as keys, the blockchain database, and networking information when you stop the node by pressing Control-c. Using the --dev option ensures that you have a clean working state any time you stop and restart the node. Verify your node is up and running successfully by reviewing the output displayed in the terminal. The terminal should display output similar to this: 2022-08-16 13:43:58 Substrate Node 2022-08-16 13:43:58 \u270c\ufe0f version 4.0.0-dev-de262935ede 2022-08-16 13:43:58 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2022 2022-08-16 13:43:58 \ud83d\udccb Chain specification: Development 2022-08-16 13:43:58 \ud83c\udff7 Node name: limping-oatmeal-7460 2022-08-16 13:43:58 \ud83d\udc64 Role: AUTHORITY 2022-08-16 13:43:58 \ud83d\udcbe Database: RocksDb at /var/folders/2_/g86ns85j5l7fdnl621ptzn500000gn/T/substrate95LPvM/chains/dev/db/full 2022-08-16 13:43:58 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2022-08-16 13:43:58 \ud83d\udd28 Initializing Genesis block/state (state: 0xf6f5\u2026423f, header-hash: 0xc665\u2026cf6a) 2022-08-16 13:43:58 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2022-08-16 13:43:59 Using default protocol ID \"sup\" because none is configured in the chain specs 2022-08-16 13:43:59 \ud83c\udff7 Local node identity is: 12D3KooWCu9uPCYZVsayaCKLdZLF8CmqiHkX2wHsAwSYVc2CxmiE ... ... ... ... 2022-08-16 13:54:26 \ud83d\udca4 Idle (0 peers), best: #3 (0xcdac\u202626e5), finalized #1 (0x107c\u20269bae), \u2b07 0 \u2b06 0 If the number after finalized is increasing, your blockchain is producing new blocks and reaching consensus about the state they describe.","title":"Run"},{"location":"setup/build/#single-node-development-chain","text":"This command will start the single-node development chain with persistent state: ./target/release/gsy-node --dev Purge the development chain's state: ./target/release/gsy-node purge-chain --dev Start the development chain with detailed logging: RUST_BACKTRACE=1 ./target/release/gsy-node -ldebug --dev","title":"Single-Node Development Chain"},{"location":"setup/connect-ui/","text":"Connect with Polkadot-JS Apps Front-end Once the node is running locally, you can connect it with Polkadot-JS Apps front-end to interact with your chain. Click Here to connect the Apps to your local node.","title":"Connect UI"},{"location":"setup/connect-ui/#connect-with-polkadot-js-apps-front-end","text":"Once the node is running locally, you can connect it with Polkadot-JS Apps front-end to interact with your chain. Click Here to connect the Apps to your local node.","title":"Connect with Polkadot-JS Apps Front-end"},{"location":"setup/docker/","text":"Run Service using Docker Compose First, install Docker and Docker Compose . Build and tag the docker image: docker build -t gsy_dex_image . docker tag gsy_dex_image:latest gsy_dex_image:staging and start docker-compose: docker-compose up","title":"Docker"},{"location":"setup/docker/#run-service-using-docker-compose","text":"First, install Docker and Docker Compose . Build and tag the docker image: docker build -t gsy_dex_image . docker tag gsy_dex_image:latest gsy_dex_image:staging and start docker-compose: docker-compose up","title":"Run Service using Docker Compose"},{"location":"setup/installation/","text":"Installation In this chapter you will learn how to: Setup your computer for Rust development Run the platform code Build the platform Connect external UI to the platform Use docker and docker-compose to build and run the platform with all the ancillary services","title":"Intro"},{"location":"setup/installation/#installation","text":"In this chapter you will learn how to: Setup your computer for Rust development Run the platform code Build the platform Connect external UI to the platform Use docker and docker-compose to build and run the platform with all the ancillary services","title":"Installation"},{"location":"setup/run/","text":"Run Use Rust's native cargo command to build and launch the gsy-node: cd gsy-node cargo run --release -- --dev --tmp You should always use the --release flag to build optimized artifacts. The command-line options specify how you want the running node to operate. In this case, the --dev option specifies that the node runs in development mode using the predefined development chain specification. By default, this option also deletes all active data\u2014such as keys, the blockchain database, and networking information when you stop the node by pressing Control-c. Using the --dev option ensures that you have a clean working state any time you stop and restart the node. Verify your node is up and running successfully by reviewing the output displayed in the terminal. The terminal should display output similar to this: 2022-08-16 13:43:58 Substrate Node 2022-08-16 13:43:58 \u270c\ufe0f version 4.0.0-dev-de262935ede 2022-08-16 13:43:58 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2022 2022-08-16 13:43:58 \ud83d\udccb Chain specification: Development 2022-08-16 13:43:58 \ud83c\udff7 Node name: limping-oatmeal-7460 2022-08-16 13:43:58 \ud83d\udc64 Role: AUTHORITY 2022-08-16 13:43:58 \ud83d\udcbe Database: RocksDb at /var/folders/2_/g86ns85j5l7fdnl621ptzn500000gn/T/substrate95LPvM/chains/dev/db/full 2022-08-16 13:43:58 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2022-08-16 13:43:58 \ud83d\udd28 Initializing Genesis block/state (state: 0xf6f5\u2026423f, header-hash: 0xc665\u2026cf6a) 2022-08-16 13:43:58 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2022-08-16 13:43:59 Using default protocol ID \"sup\" because none is configured in the chain specs 2022-08-16 13:43:59 \ud83c\udff7 Local node identity is: 12D3KooWCu9uPCYZVsayaCKLdZLF8CmqiHkX2wHsAwSYVc2CxmiE ... ... ... ... 2022-08-16 13:54:26 \ud83d\udca4 Idle (0 peers), best: #3 (0xcdac\u202626e5), finalized #1 (0x107c\u20269bae), \u2b07 0 \u2b06 0 If the number after finalized is increasing, your blockchain is producing new blocks and reaching consensus about the state they describe.","title":"Run"},{"location":"setup/run/#run","text":"Use Rust's native cargo command to build and launch the gsy-node: cd gsy-node cargo run --release -- --dev --tmp You should always use the --release flag to build optimized artifacts. The command-line options specify how you want the running node to operate. In this case, the --dev option specifies that the node runs in development mode using the predefined development chain specification. By default, this option also deletes all active data\u2014such as keys, the blockchain database, and networking information when you stop the node by pressing Control-c. Using the --dev option ensures that you have a clean working state any time you stop and restart the node. Verify your node is up and running successfully by reviewing the output displayed in the terminal. The terminal should display output similar to this: 2022-08-16 13:43:58 Substrate Node 2022-08-16 13:43:58 \u270c\ufe0f version 4.0.0-dev-de262935ede 2022-08-16 13:43:58 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2022 2022-08-16 13:43:58 \ud83d\udccb Chain specification: Development 2022-08-16 13:43:58 \ud83c\udff7 Node name: limping-oatmeal-7460 2022-08-16 13:43:58 \ud83d\udc64 Role: AUTHORITY 2022-08-16 13:43:58 \ud83d\udcbe Database: RocksDb at /var/folders/2_/g86ns85j5l7fdnl621ptzn500000gn/T/substrate95LPvM/chains/dev/db/full 2022-08-16 13:43:58 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2022-08-16 13:43:58 \ud83d\udd28 Initializing Genesis block/state (state: 0xf6f5\u2026423f, header-hash: 0xc665\u2026cf6a) 2022-08-16 13:43:58 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2022-08-16 13:43:59 Using default protocol ID \"sup\" because none is configured in the chain specs 2022-08-16 13:43:59 \ud83c\udff7 Local node identity is: 12D3KooWCu9uPCYZVsayaCKLdZLF8CmqiHkX2wHsAwSYVc2CxmiE ... ... ... ... 2022-08-16 13:54:26 \ud83d\udca4 Idle (0 peers), best: #3 (0xcdac\u202626e5), finalized #1 (0x107c\u20269bae), \u2b07 0 \u2b06 0 If the number after finalized is increasing, your blockchain is producing new blocks and reaching consensus about the state they describe.","title":"Run"},{"location":"setup/rust-setup/","text":"Rust Setup This guide is for reference only, please check the latest information on getting starting with Substrate here . This page will guide you through the 2 steps needed to prepare a computer for Substrate development. Since Substrate is built with the Rust programming language , the first thing you will need to do is prepare the computer for Rust development - these steps will vary based on the computer's operating system. Once Rust is configured, you will use its toolchains to interact with Rust projects; the commands for Rust's toolchains will be the same for all supported, Unix-based operating systems. Build dependencies Substrate development is easiest on Unix-based operating systems like macOS or Linux. The examples in the Substrate Docs use Unix-style terminals to demonstrate how to interact with Substrate from the command line. Ubuntu/Debian Use a terminal shell to execute the following commands: sudo apt update # May prompt for location information sudo apt install -y git clang curl libssl-dev llvm libudev-dev Fedora Run these commands from a terminal: sudo dnf update sudo dnf install clang curl git openssl-devel macOS Apple M1 ARM If you have an Apple M1 ARM system on a chip, make sure that you have Apple Rosetta 2 installed through softwareupdate --install-rosetta . This is only needed to run the protoc tool during the build. The build itself and the target binaries would remain native. Open the Terminal application and execute the following commands: # Install Homebrew if necessary https://brew.sh/ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" # Make sure Homebrew is up-to-date, install openssl brew update brew install openssl Rust developer environment If you want to develop and extend the Decentralized Energy Exchange you might want to follow this guide. This guide uses https://rustup.rs installer and the rustup tool to manage the Rust toolchain. First install and configure rustup : # Install curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh # Configure source ~/.cargo/env Configure the Rust toolchain to default to the latest stable version, add nightly and the nightly wasm target: rustup default stable rustup update rustup update nightly rustup target add wasm32-unknown-unknown --toolchain nightly Test your set-up Now the best way to ensure that you have successfully prepared a computer for Substrate development is to follow the steps in the first Substrate tutorial .","title":"Rust Setup"},{"location":"setup/rust-setup/#rust-setup","text":"This guide is for reference only, please check the latest information on getting starting with Substrate here . This page will guide you through the 2 steps needed to prepare a computer for Substrate development. Since Substrate is built with the Rust programming language , the first thing you will need to do is prepare the computer for Rust development - these steps will vary based on the computer's operating system. Once Rust is configured, you will use its toolchains to interact with Rust projects; the commands for Rust's toolchains will be the same for all supported, Unix-based operating systems.","title":"Rust Setup"},{"location":"setup/rust-setup/#build-dependencies","text":"Substrate development is easiest on Unix-based operating systems like macOS or Linux. The examples in the Substrate Docs use Unix-style terminals to demonstrate how to interact with Substrate from the command line.","title":"Build dependencies"},{"location":"setup/rust-setup/#ubuntudebian","text":"Use a terminal shell to execute the following commands: sudo apt update # May prompt for location information sudo apt install -y git clang curl libssl-dev llvm libudev-dev","title":"Ubuntu/Debian"},{"location":"setup/rust-setup/#fedora","text":"Run these commands from a terminal: sudo dnf update sudo dnf install clang curl git openssl-devel","title":"Fedora"},{"location":"setup/rust-setup/#macos","text":"Apple M1 ARM If you have an Apple M1 ARM system on a chip, make sure that you have Apple Rosetta 2 installed through softwareupdate --install-rosetta . This is only needed to run the protoc tool during the build. The build itself and the target binaries would remain native. Open the Terminal application and execute the following commands: # Install Homebrew if necessary https://brew.sh/ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" # Make sure Homebrew is up-to-date, install openssl brew update brew install openssl","title":"macOS"},{"location":"setup/rust-setup/#rust-developer-environment","text":"If you want to develop and extend the Decentralized Energy Exchange you might want to follow this guide. This guide uses https://rustup.rs installer and the rustup tool to manage the Rust toolchain. First install and configure rustup : # Install curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh # Configure source ~/.cargo/env Configure the Rust toolchain to default to the latest stable version, add nightly and the nightly wasm target: rustup default stable rustup update rustup update nightly rustup target add wasm32-unknown-unknown --toolchain nightly","title":"Rust developer environment"},{"location":"setup/rust-setup/#test-your-set-up","text":"Now the best way to ensure that you have successfully prepared a computer for Substrate development is to follow the steps in the first Substrate tutorial .","title":"Test your set-up"},{"location":"setup/test/","text":"Test You can verify the logic in your runtime by constructing a mock runtime environment. The configuration type Test is defined as a Rust enum with implementations for each of the pallet configuration traits that are used in the mock runtime. // Configure a mock runtime to test the pallet. frame_support::construct_runtime!( pub enum Test where Block = Block, NodeBlock = Block, UncheckedExtrinsic = UncheckedExtrinsic, { System: frame_system::{Pallet, Call, Config, Storage, Event<T>}, Balances: pallet_balances::{Pallet, Call, Storage, Config<T>, Event<T>}, OrderbookRegistry: orderbook_registry::{Pallet, Call, Storage, Event<T>}, } ); impl frame_system::Config for Test { // -- snip -- type MaxConsumers = frame_support::traits::ConstU32<16>; } Use Rust's native cargo command to build and execute the tests on the gsy-node runtime: cd gsy-node cargo test For more information about using the Rust cargo test command and testing framework, run the following command: cargo help test","title":"Test"},{"location":"setup/test/#test","text":"You can verify the logic in your runtime by constructing a mock runtime environment. The configuration type Test is defined as a Rust enum with implementations for each of the pallet configuration traits that are used in the mock runtime. // Configure a mock runtime to test the pallet. frame_support::construct_runtime!( pub enum Test where Block = Block, NodeBlock = Block, UncheckedExtrinsic = UncheckedExtrinsic, { System: frame_system::{Pallet, Call, Config, Storage, Event<T>}, Balances: pallet_balances::{Pallet, Call, Storage, Config<T>, Event<T>}, OrderbookRegistry: orderbook_registry::{Pallet, Call, Storage, Event<T>}, } ); impl frame_system::Config for Test { // -- snip -- type MaxConsumers = frame_support::traits::ConstU32<16>; } Use Rust's native cargo command to build and execute the tests on the gsy-node runtime: cd gsy-node cargo test For more information about using the Rust cargo test command and testing framework, run the following command: cargo help test","title":"Test"}]}